import { useEffect, useCallback, useMemo } from "react";
import sendMetric from "metrics";
import sendData from "data";
import bigComputations from "bigComputations";

const items = [{ id: 1 }, { id: 2 }, { id: 3 }];

const PleaseReviewMe = ({ argument }) => {
  const data = useMemo(() => bigComputations(argument), []);

  useEffect(() => {
    const handleClickMetric = () => {
      sendMetric("click");
    };
    document.addEventListener("click", handleClickMetric);

    return () => {
      document.removeEventListener("click", handleClickMetric);
    };
  }, []);

  const handleClick = useCallback((id) => {
    sendData(data, id);
  }, []);

  return (
    <>
      {items.map(({ id }) => (
        <button key={id} onClick={() => handleClick(id)}>
          {id}
        </button>
      ))}
    </>
  );
};

export { PleaseReviewMe };

// Что: Объявление переменной items
// Почему: При каждом ререндре компонентов items будет создаваться заново, а это повлияет на производительность.
// Так как items не изменяется и используется только для отображения лучшим решением будет вынести за пределы компонента
// Что: Исправить значение нулевого индекса в items
// Почему: Если значение id строка то нужно обернуть в "", если это число то нужно поставить число. Судя по следующим элементам массива там должно быть число 1.

//Что: заменить useState
//Почему: Так как мы в компоненте не меняем состояние data, то и использование useState не обоснованно

// Что: Исправить подписку на событие 'click'.
// Почему:
// 1. При размонтировании компонента, подписка останется так как не происходит отписка от события.
//  Соответственно будет утечка памяти и так как мы ссылаемся на глобальный объект "document" событие клик так же останется даже при размонтировании компонента,
//  что при клике приведёт к повторному вызову функции sendMetric('click').
// 2. При использовании стрелочной функции в подписке, а соответственно при таком же подходе в отписке от события,
// будет создаваться каждый раз в обоих случаях новая функция что не приведёт от отписки событий.
// 3. Синтаксическая ошибка в addlventListener.

// Что: Массив зависимостей в useEffect
// Почему: При отсутствии массива зависимостей useEffect будет выполняться каждый раз при ререндре компонента.

// Что: Добавить массив зависимостей
// Почему: без массива зависимостей useCallback будет заново создавать функции на каждом ререндре

// Что: исправить div
// Почему: 1. При отрисовки списка нужно использовать key, что бы в данном случае react заново не перерисовывал список.
// 2. Есть возможность деструктурировать item для более комфортной читаемости кода
// 3. Для правильной семантической верстки, если мы хотим кликать на элемент в данном случае нужно использовать button
